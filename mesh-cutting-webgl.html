<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ë©”ì‰¬ ì»¤íŒ… - ìˆœìˆ˜ WebGL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        canvas {
            display: block;
            border: 3px solid #667eea;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        #container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            max-width: 300px;
        }
        
        h3 {
            margin: 0 0 10px 0;
            color: #667eea;
        }
        
        .stat {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .stat strong {
            color: #333;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .btn-reset {
            background: #ff6b6b;
            color: white;
        }
        
        .btn-wireframe {
            background: #4dabf7;
            color: white;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="gl-canvas" width="1024" height="768"></canvas>
    </div>
    
    <div id="info">
        <h3>ğŸ”ª WebGL ë©”ì‰¬ ì»¤íŒ…</h3>
        <div class="stat"><strong>ë Œë”ë§:</strong> WebGL</div>
        <div class="stat"><strong>Shader:</strong> ì»¤ìŠ¤í…€ GLSL</div>
        <div class="stat"><strong>ì •ì :</strong> <span id="vertexCount">0</span></div>
        <div class="stat"><strong>ë©”ì‰¬:</strong> <span id="meshCount">1</span></div>
        <div class="stat"><strong>FPS:</strong> <span id="fps">60</span></div>
        <hr style="margin: 10px 0;">
        <small>
            ì¢Œí´ë¦­ ë“œë˜ê·¸: ë©”ì‰¬ ì ˆë‹¨<br>
            ìš°í´ë¦­ ë“œë˜ê·¸: ì¹´ë©”ë¼ íšŒì „
        </small>
    </div>
    
    <div id="controls">
        <button class="btn-reset" onclick="resetScene()">ğŸ”„ ì´ˆê¸°í™”</button>
        <button class="btn-wireframe" onclick="toggleWireframe()">ğŸ” ì™€ì´ì–´í”„ë ˆì„</button>
    </div>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 vPosition;
        attribute vec4 vColor;
        
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        
        varying vec4 fColor;
        
        void main() {
            gl_Position = uProjectionMatrix * uModelViewMatrix * vPosition;
            fColor = vColor;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying vec4 fColor;
        
        void main() {
            gl_FragColor = fColor;
        }
    </script>

    <!-- WebGL ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script type="text/javascript" src="libs/webgl-utils.js"></script>
    <script type="text/javascript" src="libs/InitShaders.js"></script>
    <script type="text/javascript" src="libs/MV.js"></script>

    <!-- ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ -->
    <script type="text/javascript">
        "use strict";

        // WebGL ë³€ìˆ˜
        let canvas;
        let gl;
        let program;

        // Uniform ìœ„ì¹˜
        let uModelViewMatrix;
        let uProjectionMatrix;

        // ë²„í¼
        let vBuffer;
        let cBuffer;

        // ì¹´ë©”ë¼
        let eye = vec3(0, 0, 5);
        let at = vec3(0, 0, 0);
        let up = vec3(0, 1, 0);

        // íˆ¬ì˜
        let fovy = 45.0;
        let aspect;
        let near = 0.1;
        let far = 100.0;

        // ë©”ì‰¬ ë°ì´í„°
        let meshes = [];
        let wireframeMode = false;

        // ë§ˆìš°ìŠ¤
        let isDragging = false;
        let startPoint = null;
        let endPoint = null;
        let isRotating = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;

        // ë©”ì‰¬ í´ë˜ìŠ¤
        class Mesh {
            constructor(vertices, color) {
                this.vertices = vertices; // vec3 ë°°ì—´
                this.color = color;       // vec4
                this.velocity = vec3(0, 0, 0);
                this.position = vec3(0, 0, 0);
                this.rotation = 0;
            }

            update(deltaTime) {
                // ê°„ë‹¨í•œ ë¬¼ë¦¬ (ì¤‘ë ¥)
                this.velocity[1] -= 0.5 * deltaTime;
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                this.position = add(this.position, scale(deltaTime, this.velocity));
                
                // ë°”ë‹¥ ì¶©ëŒ
                if (this.position[1] < -3) {
                    this.position[1] = -3;
                    this.velocity[1] *= -0.5;
                    this.velocity[0] *= 0.9;
                }
                
                // íšŒì „
                this.rotation += 0.5 * deltaTime;
            }

            getTransformedVertices() {
                // ë³€í™˜ ì ìš©
                let transformed = [];
                for (let v of this.vertices) {
                    // íšŒì „
                    let cosR = Math.cos(this.rotation);
                    let sinR = Math.sin(this.rotation);
                    let rotated = vec3(
                        v[0] * cosR - v[2] * sinR,
                        v[1],
                        v[0] * sinR + v[2] * cosR
                    );
                    // ì´ë™
                    transformed.push(add(rotated, this.position));
                }
                return transformed;
            }
        }

        // ì´ˆê¸°í™”
        window.onload = function init() {
            console.log('ğŸš€ WebGL ì´ˆê¸°í™” ì‹œì‘');
            
            canvas = document.getElementById("gl-canvas");
            
            gl = WebGLUtils.setupWebGL(canvas);
            if (!gl) {
                alert("WebGLì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
                return;
            }

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.1, 0.1, 0.18, 1.0);
            gl.enable(gl.DEPTH_TEST);

            // Shader í”„ë¡œê·¸ë¨ ë¡œë“œ
            program = initShaders(gl, "vertex-shader", "fragment-shader");
            gl.useProgram(program);

            // Uniform ìœ„ì¹˜
            uModelViewMatrix = gl.getUniformLocation(program, "uModelViewMatrix");
            uProjectionMatrix = gl.getUniformLocation(program, "uProjectionMatrix");

            // ë²„í¼ ìƒì„±
            vBuffer = gl.createBuffer();
            cBuffer = gl.createBuffer();

            // Attribute ìœ„ì¹˜
            let vPosition = gl.getAttribLocation(program, "vPosition");
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.vertexAttribPointer(vPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vPosition);

            let vColor = gl.getAttribLocation(program, "vColor");
            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.vertexAttribPointer(vColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vColor);

            // ì´ˆê¸° ë©”ì‰¬ ìƒì„±
            createInitialMesh();

            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            setupEventListeners();

            // Aspect ratio
            aspect = canvas.width / canvas.height;

            console.log('âœ… WebGL ì´ˆê¸°í™” ì™„ë£Œ');
            
            // ë Œë”ë§ ì‹œì‘
            render();
        }

        function createInitialMesh() {
            // ì‚¬ê°í˜• ë©”ì‰¬
            let vertices = [
                vec3(-1, 1, 0),
                vec3(-1, -1, 0),
                vec3(1, -1, 0),
                vec3(-1, 1, 0),
                vec3(1, -1, 0),
                vec3(1, 1, 0)
            ];
            
            let color = vec4(0.5, 0.75, 0.12, 1.0);
            meshes.push(new Mesh(vertices, color));
            
            updateStats();
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', function(e) {
                if (e.button === 0) {
                    // ì¢Œí´ë¦­ - ì ˆë‹¨
                    isDragging = true;
                    startPoint = getCanvasPoint(e);
                } else if (e.button === 2) {
                    // ìš°í´ë¦­ - íšŒì „
                    isRotating = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
                e.preventDefault();
            });

            canvas.addEventListener('mousemove', function(e) {
                if (isDragging && startPoint) {
                    endPoint = getCanvasPoint(e);
                } else if (isRotating) {
                    let deltaX = e.clientX - lastMouseX;
                    let deltaY = e.clientY - lastMouseY;
                    
                    cameraAngleY += deltaX * 0.01;
                    cameraAngleX += deltaY * 0.01;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', function(e) {
                if (e.button === 0 && isDragging) {
                    if (startPoint && endPoint) {
                        performCut();
                    }
                    isDragging = false;
                    startPoint = null;
                    endPoint = null;
                } else if (e.button === 2) {
                    isRotating = false;
                }
            });

            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }

        function getCanvasPoint(e) {
            let rect = canvas.getBoundingClientRect();
            let x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
            let y = -((e.clientY - rect.top) / canvas.height) * 2 + 1;
            return vec2(x, y);
        }

        function performCut() {
            console.log('ğŸ”ª ë©”ì‰¬ ì ˆë‹¨ ì‹œë„');
            // ê°„ë‹¨í•œ êµ¬í˜„: ë©”ì‰¬ë¥¼ ë‘ ê°œë¡œ ë³µì œ
            if (meshes.length > 0) {
                let originalMesh = meshes[0];
                meshes = [];
                
                // ì™¼ìª½ ì ˆë°˜
                let vertices1 = [
                    vec3(-1, 1, 0),
                    vec3(-1, -1, 0),
                    vec3(0, -1, 0),
                    vec3(-1, 1, 0),
                    vec3(0, -1, 0),
                    vec3(0, 1, 0)
                ];
                let mesh1 = new Mesh(vertices1, vec4(Math.random(), Math.random(), Math.random(), 1));
                mesh1.velocity = vec3(-0.5, 1, 0);
                meshes.push(mesh1);
                
                // ì˜¤ë¥¸ìª½ ì ˆë°˜
                let vertices2 = [
                    vec3(0, 1, 0),
                    vec3(0, -1, 0),
                    vec3(1, -1, 0),
                    vec3(0, 1, 0),
                    vec3(1, -1, 0),
                    vec3(1, 1, 0)
                ];
                let mesh2 = new Mesh(vertices2, vec4(Math.random(), Math.random(), Math.random(), 1));
                mesh2.velocity = vec3(0.5, 1, 0);
                meshes.push(mesh2);
                
                updateStats();
                console.log('âœ… ë©”ì‰¬ ì ˆë‹¨ ì™„ë£Œ');
            }
        }

        function resetScene() {
            meshes = [];
            createInitialMesh();
            cameraAngleX = 0;
            cameraAngleY = 0;
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
        }

        function updateStats() {
            let totalVertices = 0;
            meshes.forEach(m => totalVertices += m.vertices.length);
            
            document.getElementById('vertexCount').textContent = totalVertices;
            document.getElementById('meshCount').textContent = meshes.length;
        }

        let lastTime = 0;
        let frameCount = 0;
        let fpsTime = 0;

        function render(time = 0) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            let deltaTime = (time - lastTime) / 1000;
            lastTime = time;
            
            // FPS ê³„ì‚°
            frameCount++;
            fpsTime += deltaTime;
            if (fpsTime >= 1.0) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                fpsTime = 0;
            }

            // ë©”ì‰¬ ì—…ë°ì´íŠ¸
            meshes.forEach(mesh => mesh.update(deltaTime));

            // ì¹´ë©”ë¼ ì„¤ì •
            let radius = 5;
            eye = vec3(
                radius * Math.sin(cameraAngleY) * Math.cos(cameraAngleX),
                radius * Math.sin(cameraAngleX),
                radius * Math.cos(cameraAngleY) * Math.cos(cameraAngleX)
            );
            
            let modelViewMatrix = lookAt(eye, at, up);
            let projectionMatrix = perspective(fovy, aspect, near, far);

            gl.uniformMatrix4fv(uModelViewMatrix, false, flatten(modelViewMatrix));
            gl.uniformMatrix4fv(uProjectionMatrix, false, flatten(projectionMatrix));

            // ëª¨ë“  ë©”ì‰¬ ë Œë”ë§
            meshes.forEach(mesh => renderMesh(mesh));

            // ì ˆë‹¨ì„  ê·¸ë¦¬ê¸°
            if (isDragging && startPoint && endPoint) {
                renderCutLine();
            }

            requestAnimationFrame(render);
        }

        function renderMesh(mesh) {
            let vertices = mesh.getTransformedVertices();
            let colors = [];
            
            for (let i = 0; i < vertices.length; i++) {
                colors.push(mesh.color);
            }

            // ë²„í¼ ì—…ë°ì´íŠ¸
            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices), gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.DYNAMIC_DRAW);

            // ê·¸ë¦¬ê¸°
            if (wireframeMode) {
                gl.drawArrays(gl.LINE_LOOP, 0, vertices.length);
            } else {
                gl.drawArrays(gl.TRIANGLES, 0, vertices.length);
            }
        }

        function renderCutLine() {
            let vertices = [
                vec3(startPoint[0] * 3, startPoint[1] * 3, 0),
                vec3(endPoint[0] * 3, endPoint[1] * 3, 0)
            ];
            
            let colors = [
                vec4(1, 0, 0, 1),
                vec4(1, 0, 0, 1)
            ];

            gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices), gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.DYNAMIC_DRAW);

            gl.drawArrays(gl.LINES, 0, 2);
        }
    </script>
</body>
</html>

